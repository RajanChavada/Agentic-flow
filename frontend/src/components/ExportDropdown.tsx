"use client";

import React, { useState, useRef, useEffect, useCallback } from "react";
import { toPng, toSvg } from "html-to-image";
import {
  Image,
  Palette,
  Camera,
  FileText,
  Table2,
  ClipboardList,
  FileCode,
  ChevronDown,
} from "lucide-react";
import {
  useWorkflowNodes,
  useWorkflowEdges,
  useEstimation,
} from "@/store/useWorkflowStore";
import { useUser, useAuthStore } from "@/store/useAuthStore";
import type {
  WorkflowEstimation,
  NodeEstimation,
} from "@/types/workflow";

// ── Helpers ──────────────────────────────────────────────────

/** Trigger a browser download of the given data URL or Blob. */
function downloadDataUrl(dataUrl: string, filename: string) {
  const a = document.createElement("a");
  a.href = dataUrl;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
}

function downloadBlob(content: string, filename: string, mime: string) {
  const blob = new Blob([content], { type: mime });
  const url = URL.createObjectURL(blob);
  downloadDataUrl(url, filename);
  URL.revokeObjectURL(url);
}

// ── Markdown report builder ─────────────────────────────────

function buildMarkdownReport(est: WorkflowEstimation): string {
  const lines: string[] = [];
  const ts = new Date().toISOString();

  lines.push("# Agentic Flow — Workflow Estimation Report");
  lines.push(`> Generated: ${ts}\n`);

  // Summary
  lines.push("## Summary\n");
  lines.push(`| Metric | Value |`);
  lines.push(`|--------|-------|`);
  lines.push(`| Graph type | ${est.graph_type} |`);
  lines.push(`| Total tokens | ${est.total_tokens.toLocaleString()} |`);
  lines.push(`| Input tokens | ${est.total_input_tokens.toLocaleString()} |`);
  lines.push(`| Output tokens | ${est.total_output_tokens.toLocaleString()} |`);
  lines.push(`| Total cost | $${est.total_cost.toFixed(5)} |`);
  lines.push(`| Total latency | ${(est.total_latency * 1000).toFixed(0)} ms |`);
  lines.push(`| Tool latency | ${(est.total_tool_latency * 1000).toFixed(0)} ms |`);
  lines.push(`| Critical-path latency | ${(est.critical_path_latency * 1000).toFixed(0)} ms |`);
  lines.push("");

  // Health score
  if (est.health) {
    lines.push("## Health Score\n");
    lines.push(`**Grade: ${est.health.grade}** (${est.health.score}/100)\n`);
    if (est.health.badges.length) {
      lines.push(`Badges: ${est.health.badges.map((b) => `\`${b}\``).join(", ")}\n`);
    }
  }

  // Node breakdown
  lines.push("## Node Breakdown\n");
  lines.push(`| Node | Tokens | Cost | Latency (ms) | Bottleneck |`);
  lines.push(`|------|--------|------|-------------|------------|`);
  for (const n of est.breakdown) {
    lines.push(
      `| ${n.node_name} | ${n.tokens.toLocaleString()} | $${n.cost.toFixed(5)} | ${(n.latency * 1000).toFixed(0)} | ${n.bottleneck_severity ?? "—"} |`
    );
  }
  lines.push("");

  // Critical path (resolve IDs to names)
  if (est.critical_path.length) {
    const idToLabel: Record<string, string> = {};
    for (const n of est.breakdown) idToLabel[n.node_id] = n.node_name;
    const pathLabels = est.critical_path.map((id) => idToLabel[id] ?? id);
    lines.push("## Critical Path\n");
    lines.push(pathLabels.join(" → "));
    lines.push(`\n*Total critical-path latency: ${(est.critical_path_latency * 1000).toFixed(0)} ms*`);
    lines.push("");
  }

  // Cycles
  if (est.detected_cycles.length) {
    lines.push("## Detected Cycles\n");
    for (const c of est.detected_cycles) {
      lines.push(`- **Cycle ${c.cycle_id}**: ${c.node_labels.join(" → ")} (${c.risk_level} risk, ~${c.expected_iterations} iterations)`);
    }
    lines.push("");
  }

  // Parallel steps
  if (est.parallel_steps.length) {
    lines.push("## Parallel Execution Steps\n");
    for (const s of est.parallel_steps) {
      lines.push(`- **Step ${s.step}** (×${s.parallelism} parallel): ${s.node_labels.join(", ")} — ${(s.total_latency * 1000).toFixed(0)} ms, $${s.total_cost.toFixed(5)}`);
    }
    lines.push("");
  }

  // Scaling
  if (est.scaling_projection) {
    const sp = est.scaling_projection;
    lines.push("## Scaling Projection\n");
    lines.push(`| Metric | Value |`);
    lines.push(`|--------|-------|`);
    lines.push(`| Runs/day | ${sp.runs_per_day.toLocaleString()} |`);
    lines.push(`| Runs/month | ${sp.runs_per_month.toLocaleString()} |`);
    lines.push(`| Monthly cost | $${sp.monthly_cost.toFixed(2)} |`);
    lines.push(`| Monthly tokens | ${sp.monthly_tokens.toLocaleString()} |`);
    lines.push(`| Cost per 1k runs | $${sp.cost_per_1k_runs.toFixed(4)} |`);
    lines.push("");
  }

  lines.push("---");
  lines.push("*Report generated by Agentic Flow Designer*\n");
  return lines.join("\n");
}

// ── JSON report builder ─────────────────────────────────────

function buildJsonReport(
  est: WorkflowEstimation,
  nodes: { id: string; type?: string; data: Record<string, unknown> }[],
  edges: { id: string; source: string; target: string }[]
) {
  return JSON.stringify(
    {
      generated_at: new Date().toISOString(),
      estimation: est,
      graph: {
        nodes: nodes.map((n) => ({
          id: n.id,
          type: n.type,
          label: (n.data as Record<string, unknown>).label,
        })),
        edges: edges.map((e) => ({
          id: e.id,
          source: e.source,
          target: e.target,
        })),
      },
    },
    null,
    2
  );
}

// ── Component ────────────────────────────────────────────────

/** Build a CSV string from the estimation breakdown table. */
function buildCsvReport(est: WorkflowEstimation): string {
  const rows: string[] = [];
  // Header
  rows.push(
    [
      "Node",
      "Model Provider",
      "Model Name",
      "Input Tokens",
      "Output Tokens",
      "Total Tokens",
      "Input Cost ($)",
      "Output Cost ($)",
      "Total Cost ($)",
      "Latency (ms)",
      "Tool Latency (ms)",
      "Tool Schema Tokens",
      "Tool Response Tokens",
      "Cost Share (%)",
      "Latency Share (%)",
      "Bottleneck Severity",
      "In Cycle",
    ].join(",")
  );
  // Data rows
  for (const n of est.breakdown) {
    rows.push(
      [
        `"${n.node_name}"`,
        `"${n.model_provider ?? ""}"`,
        `"${n.model_name ?? ""}"`,
        n.input_tokens,
        n.output_tokens,
        n.tokens,
        n.input_cost.toFixed(6),
        n.output_cost.toFixed(6),
        n.cost.toFixed(6),
        (n.latency * 1000).toFixed(1),
        (n.tool_latency * 1000).toFixed(1),
        n.tool_schema_tokens,
        n.tool_response_tokens,
        (n.cost_share * 100).toFixed(1),
        (n.latency_share * 100).toFixed(1),
        n.bottleneck_severity ?? "",
        n.in_cycle,
      ].join(",")
    );
  }
  // Totals row
  rows.push(
    [
      '"TOTAL"',
      '""',
      '""',
      est.total_input_tokens,
      est.total_output_tokens,
      est.total_tokens,
      "",
      "",
      est.total_cost.toFixed(6),
      (est.total_latency * 1000).toFixed(1),
      (est.total_tool_latency * 1000).toFixed(1),
      "",
      "",
      "100.0",
      "100.0",
      "",
      "",
    ].join(",")
  );
  return rows.join("\n");
}

/** Generate a PDF report from the estimation data using jsPDF. */
async function generatePdfReport(
  est: WorkflowEstimation,
  isDark: boolean
): Promise<void> {
  // Import jspdf-autotable first — it patches jsPDF.prototype.autoTable
  const jsPDFModule = await import("jspdf");
  const autoTableModule = await import("jspdf-autotable");
  const jsPDF = jsPDFModule.default;
  const autoTable = autoTableModule.default;

  const doc = new jsPDF({ orientation: "portrait", unit: "mm", format: "a4" });
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();
  const margin = 14;
  const contentWidth = pageWidth - margin * 2;
  let y = 15;

  // ── ID → label lookup (critical path uses IDs, not names) ─
  const idToName: Record<string, string> = {};
  for (const n of est.breakdown) {
    idToName[n.node_id] = n.node_name;
  }

  /** Ensure enough room; add a new page if needed. */
  const ensureSpace = (needed: number) => {
    if (y + needed > pageHeight - 20) {
      doc.addPage();
      y = 15;
    }
  };

  /** Section heading helper — uses a colored underline instead of emoji. */
  const heading = (text: string, color: [number, number, number] = [30, 64, 175]) => {
    ensureSpace(20);
    doc.setFontSize(13);
    doc.setFont("helvetica", "bold");
    doc.setTextColor(...color);
    doc.text(text, margin, y);
    y += 1.5;
    // Colored underline
    doc.setDrawColor(...color);
    doc.setLineWidth(0.6);
    const textWidth = doc.getTextWidth(text);
    doc.line(margin, y, margin + textWidth + 2, y);
    doc.setDrawColor(0);
    doc.setTextColor(0);
    y += 6;
  };

  /** Run autoTable and advance y. */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const table = (opts: Record<string, any>) => {
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    autoTable(doc as any, { ...opts, startY: y, margin: { left: margin, right: margin } });
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    y = (doc as any).lastAutoTable.finalY + 8;
  };

  // ─────────────────────────────────────────────────────────
  // TITLE
  // ─────────────────────────────────────────────────────────
  doc.setFontSize(20);
  doc.setFont("helvetica", "bold");
  doc.setTextColor(30, 64, 175); // blue-800
  doc.text("Agentic Flow", pageWidth / 2, y, { align: "center" });
  y += 7;
  doc.setFontSize(11);
  doc.setFont("helvetica", "normal");
  doc.setTextColor(100);
  doc.text("Workflow Estimation Report", pageWidth / 2, y, { align: "center" });
  y += 5;
  doc.setFontSize(8);
  doc.text(new Date().toLocaleString(), pageWidth / 2, y, { align: "center" });
  doc.setTextColor(0);
  y += 3;

  // Divider line
  doc.setDrawColor(200);
  doc.setLineWidth(0.3);
  doc.line(margin, y, pageWidth - margin, y);
  y += 8;

  // ─────────────────────────────────────────────────────────
  // 1. SUMMARY
  // ─────────────────────────────────────────────────────────
  heading("Summary", [59, 130, 246]);

  const summaryData: string[][] = [
    ["Graph Type", est.graph_type],
    ["Total Tokens", est.total_tokens.toLocaleString()],
    ["  - Input", est.total_input_tokens.toLocaleString()],
    ["  - Output", est.total_output_tokens.toLocaleString()],
    ["Total Cost", `$${est.total_cost.toFixed(5)}`],
    ["Total Latency", `${(est.total_latency * 1000).toFixed(0)} ms`],
    ["Tool Latency", `${(est.total_tool_latency * 1000).toFixed(0)} ms`],
    ["Critical-Path Latency", `${(est.critical_path_latency * 1000).toFixed(0)} ms`],
    ["Nodes", String(est.breakdown.length)],
  ];

  table({
    head: [["Metric", "Value"]],
    body: summaryData,
    theme: "grid",
    headStyles: { fillColor: [59, 130, 246], fontSize: 9, fontStyle: "bold" },
    bodyStyles: { fontSize: 9 },
    alternateRowStyles: { fillColor: [245, 247, 250] },
  });

  // ─────────────────────────────────────────────────────────
  // 2. HEALTH SCORE
  // ─────────────────────────────────────────────────────────
  if (est.health) {
    const gradeColor: Record<string, number[]> = {
      A: [34, 197, 94],
      B: [132, 204, 22],
      C: [234, 179, 8],
      D: [249, 115, 22],
      F: [239, 68, 68],
    };
    const gc = gradeColor[est.health.grade] ?? [100, 100, 100];

    heading("Health Score", gc as [number, number, number]);

    const healthData: string[][] = [
      ["Grade", `${est.health.grade}  (${est.health.score} / 100)`],
      ["Badges", est.health.badges.length > 0 ? est.health.badges.join(", ") : "None"],
    ];

    // Add sub-scores if available
    for (const [key, detail] of Object.entries(est.health.details)) {
      const label = key.replace(/_/g, " ").replace(/\b\w/g, (c) => c.toUpperCase());
      healthData.push([`  - ${label}`, `${detail.score} / 25`]);
    }

    table({
      head: [["Metric", "Value"]],
      body: healthData,
      theme: "grid",
      headStyles: { fillColor: gc, fontSize: 9, fontStyle: "bold" },
      bodyStyles: { fontSize: 9 },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 3. NODE BREAKDOWN
  // ─────────────────────────────────────────────────────────
  heading("Node Breakdown", [59, 130, 246]);

  const breakdownHead = ["Node", "Provider / Model", "Tokens (In/Out)", "Cost", "Latency", "Cost %", "Bottleneck"];
  const breakdownBody = est.breakdown.map((n) => [
    n.node_name,
    [n.model_provider, n.model_name].filter(Boolean).join(" / ") || "--",
    n.tokens > 0 ? `${n.tokens.toLocaleString()} (${n.input_tokens}/${n.output_tokens})` : "--",
    n.cost > 0 ? `$${n.cost.toFixed(5)}` : "--",
    n.latency > 0 ? `${(n.latency * 1000).toFixed(0)} ms` : "--",
    n.cost_share > 0 ? `${(n.cost_share * 100).toFixed(1)}%` : "--",
    n.bottleneck_severity ?? "--",
  ]);

  // Totals row
  breakdownBody.push([
    "TOTAL",
    "",
    `${est.total_tokens.toLocaleString()} (${est.total_input_tokens}/${est.total_output_tokens})`,
    `$${est.total_cost.toFixed(5)}`,
    `${(est.total_latency * 1000).toFixed(0)} ms`,
    "100%",
    "",
  ]);

  table({
    head: [breakdownHead],
    body: breakdownBody,
    theme: "striped",
    headStyles: { fillColor: [59, 130, 246], fontSize: 8, fontStyle: "bold" },
    bodyStyles: { fontSize: 8 },
    columnStyles: {
      0: { cellWidth: 25 },
      1: { cellWidth: 30 },
      6: { cellWidth: 18 },
    },
    // Bold the totals row
    didParseCell: (data: { row: { index: number }; cell: { styles: { fontStyle: string } }; section: string }) => {
      if (data.section === "body" && data.row.index === breakdownBody.length - 1) {
        data.cell.styles.fontStyle = "bold";
      }
    },
  });

  // ─────────────────────────────────────────────────────────
  // 4. CRITICAL PATH (as a styled flow table, not raw IDs)
  // ─────────────────────────────────────────────────────────
  if (est.critical_path.length > 0) {
    heading("Critical Path", [99, 102, 241]);

    // Resolve IDs to names
    const pathNames = est.critical_path.map((id) => idToName[id] ?? id);
    const pathStr = pathNames.join("  >  ");

    // Also build per-hop detail rows
    const hops: string[][] = [];
    for (let i = 0; i < est.critical_path.length; i++) {
      const nodeId = est.critical_path[i];
      const name = idToName[nodeId] ?? nodeId;
      const b = est.breakdown.find((n) => n.node_id === nodeId);
      hops.push([
        String(i + 1),
        name,
        b ? `${(b.latency * 1000).toFixed(0)} ms` : "--",
        b ? `$${b.cost.toFixed(5)}` : "--",
        b && b.bottleneck_severity ? b.bottleneck_severity : "--",
      ]);
    }

    // Summary line
    doc.setFontSize(9);
    doc.setFont("helvetica", "normal");
    doc.text(`${pathStr}`, margin, y, { maxWidth: contentWidth });
    const lineCount = doc.splitTextToSize(pathStr, contentWidth).length;
    y += lineCount * 4 + 4;

    doc.setFontSize(8);
    doc.setTextColor(100);
    doc.text(`Total critical-path latency: ${(est.critical_path_latency * 1000).toFixed(0)} ms`, margin, y);
    doc.setTextColor(0);
    y += 6;

    table({
      head: [["#", "Node", "Latency", "Cost", "Bottleneck"]],
      body: hops,
      theme: "grid",
      headStyles: { fillColor: [99, 102, 241], fontSize: 8, fontStyle: "bold" },
      bodyStyles: { fontSize: 8 },
      columnStyles: {
        0: { cellWidth: 10, halign: "center" },
        4: { cellWidth: 22 },
      },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 5. ESTIMATION RANGES (min → avg → max)
  // ─────────────────────────────────────────────────────────
  if (est.cost_range || est.token_range || est.latency_range) {
    heading("Estimation Ranges", [168, 85, 247]);

    const rangeData: string[][] = [];
    if (est.token_range) {
      rangeData.push([
        "Tokens",
        est.token_range.min.toLocaleString(),
        est.token_range.avg.toLocaleString(),
        est.token_range.max.toLocaleString(),
      ]);
    }
    if (est.cost_range) {
      rangeData.push([
        "Cost",
        `$${est.cost_range.min.toFixed(5)}`,
        `$${est.cost_range.avg.toFixed(5)}`,
        `$${est.cost_range.max.toFixed(5)}`,
      ]);
    }
    if (est.latency_range) {
      rangeData.push([
        "Latency",
        `${(est.latency_range.min * 1000).toFixed(0)} ms`,
        `${(est.latency_range.avg * 1000).toFixed(0)} ms`,
        `${(est.latency_range.max * 1000).toFixed(0)} ms`,
      ]);
    }

    table({
      head: [["Metric", "Min", "Average", "Max"]],
      body: rangeData,
      theme: "grid",
      headStyles: { fillColor: [168, 85, 247], fontSize: 9, fontStyle: "bold" },
      bodyStyles: { fontSize: 9 },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 6. SENSITIVITY (cost & latency across loop assumptions)
  // ─────────────────────────────────────────────────────────
  if (est.sensitivity) {
    heading("Sensitivity Analysis", [236, 72, 153]);
    const s = est.sensitivity;

    table({
      head: [["Metric", "Min", "Average", "Max", "Spread"]],
      body: [
        [
          "Cost",
          `$${s.cost_min.toFixed(5)}`,
          `$${s.cost_avg.toFixed(5)}`,
          `$${s.cost_max.toFixed(5)}`,
          s.cost_min > 0 ? `${(s.cost_max / s.cost_min).toFixed(1)}x` : "--",
        ],
        [
          "Latency",
          `${(s.latency_min * 1000).toFixed(0)} ms`,
          `${(s.latency_avg * 1000).toFixed(0)} ms`,
          `${(s.latency_max * 1000).toFixed(0)} ms`,
          s.latency_min > 0 ? `${(s.latency_max / s.latency_min).toFixed(1)}x` : "--",
        ],
      ],
      theme: "grid",
      headStyles: { fillColor: [236, 72, 153], fontSize: 9, fontStyle: "bold" },
      bodyStyles: { fontSize: 9 },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 7. DETECTED CYCLES
  // ─────────────────────────────────────────────────────────
  if (est.detected_cycles.length > 0) {
    heading("Detected Cycles", [239, 68, 68]);

    const cycleBody = est.detected_cycles.map((c) => [
      `Cycle ${c.cycle_id}`,
      c.node_labels.join(" > "),
      String(c.expected_iterations),
      `${c.max_iterations}`,
      c.risk_level ?? "--",
      `$${c.cost_per_lap.toFixed(5)}`,
      `${(c.latency_per_lap * 1000).toFixed(0)} ms`,
      `${(c.cost_contribution * 100).toFixed(0)}%`,
    ]);

    table({
      head: [["Cycle", "Nodes", "Avg Iters", "Max Iters", "Risk", "Cost/Lap", "Latency/Lap", "Cost Contrib."]],
      body: cycleBody,
      theme: "grid",
      headStyles: { fillColor: [239, 68, 68], fontSize: 7, fontStyle: "bold" },
      bodyStyles: { fontSize: 7 },
      columnStyles: { 1: { cellWidth: 40 } },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 8. PARALLEL EXECUTION STEPS
  // ─────────────────────────────────────────────────────────
  if (est.parallel_steps.length > 0) {
    heading("Parallel Execution Steps", [139, 92, 246]);

    const paraBody = est.parallel_steps.map((s) => [
      `Step ${s.step}`,
      `x${s.parallelism}`,
      s.node_labels.join(", "),
      `${(s.total_latency * 1000).toFixed(0)} ms`,
      `$${s.total_cost.toFixed(5)}`,
    ]);

    table({
      head: [["Step", "Parallelism", "Nodes", "Latency", "Cost"]],
      body: paraBody,
      theme: "grid",
      headStyles: { fillColor: [139, 92, 246], fontSize: 8, fontStyle: "bold" },
      bodyStyles: { fontSize: 8 },
    });
  }

  // ─────────────────────────────────────────────────────────
  // 9. MODEL MIX ANALYSIS
  // ─────────────────────────────────────────────────────────
  {
    // Aggregate cost and latency by model
    const modelMap = new Map<string, { cost: number; latency: number; tokens: number; count: number }>();
    for (const n of est.breakdown) {
      const key = [n.model_provider, n.model_name].filter(Boolean).join(" / ") || "No model";
      const existing = modelMap.get(key) ?? { cost: 0, latency: 0, tokens: 0, count: 0 };
      existing.cost += n.cost;
      existing.latency += n.latency;
      existing.tokens += n.tokens;
      existing.count += 1;
      modelMap.set(key, existing);
    }

    if (modelMap.size > 0) {
      heading("Model Mix Analysis", [14, 165, 233]);

      const modelBody = [...modelMap.entries()].map(([model, data]) => [
        model,
        `${data.count} node${data.count > 1 ? "s" : ""}`,
        data.tokens.toLocaleString(),
        `$${data.cost.toFixed(5)}`,
        `${(data.latency * 1000).toFixed(0)} ms`,
        est.total_cost > 0 ? `${((data.cost / est.total_cost) * 100).toFixed(0)}%` : "--",
      ]);

      table({
        head: [["Model", "Nodes", "Tokens", "Cost", "Latency", "Cost Share"]],
        body: modelBody,
        theme: "grid",
        headStyles: { fillColor: [14, 165, 233], fontSize: 8, fontStyle: "bold" },
        bodyStyles: { fontSize: 8 },
      });
    }
  }

  // ─────────────────────────────────────────────────────────
  // 10. SCALING PROJECTION
  // ─────────────────────────────────────────────────────────
  if (est.scaling_projection) {
    heading("Scaling Projection", [34, 197, 94]);
    const sp = est.scaling_projection;

    table({
      head: [["Metric", "Value"]],
      body: [
        ["Runs / day", sp.runs_per_day.toLocaleString()],
        ["Runs / month", sp.runs_per_month.toLocaleString()],
        ["Loop intensity", `${sp.loop_intensity.toFixed(1)}x`],
        ["Monthly cost", `$${sp.monthly_cost.toFixed(2)}`],
        ["Monthly tokens", sp.monthly_tokens.toLocaleString()],
        ["Monthly compute (sec)", sp.monthly_compute_seconds.toLocaleString()],
        ["Cost per 1k runs", `$${sp.cost_per_1k_runs.toFixed(4)}`],
      ],
      theme: "grid",
      headStyles: { fillColor: [34, 197, 94], fontSize: 9, fontStyle: "bold" },
      bodyStyles: { fontSize: 9 },
      alternateRowStyles: { fillColor: [240, 253, 244] },
    });
  }

  // ─────────────────────────────────────────────────────────
  // FOOTER — page numbers on every page
  // ─────────────────────────────────────────────────────────
  const pageCount = doc.getNumberOfPages();
  for (let i = 1; i <= pageCount; i++) {
    doc.setPage(i);
    doc.setFontSize(7);
    doc.setTextColor(150);
    doc.text(
      `Agentic Flow Designer  |  Page ${i} of ${pageCount}`,
      pageWidth / 2,
      pageHeight - 8,
      { align: "center" }
    );
    // Top-right page marker
    doc.text(`${i}/${pageCount}`, pageWidth - margin, 8, { align: "right" });
  }

  doc.save("agentic-flow-report.pdf");
}

interface Props {
  isDark: boolean;
}

export default function ExportDropdown({ isDark }: Props) {
  const [open, setOpen] = useState(false);
  const [exporting, setExporting] = useState<string | null>(null);
  const dropdownRef = useRef<HTMLDivElement>(null);
  const estimation = useEstimation();
  const nodes = useWorkflowNodes();
  const edges = useWorkflowEdges();

  // Auth gate
  const user = useUser();
  const { openAuthModal } = useAuthStore();

  const handleToggle = () => {
    if (!user) {
      openAuthModal({
        reason: "Sign in to export workflows and reports.",
        onSuccess: () => setOpen(true),
      });
      return;
    }
    setOpen(!open);
  };

  // Close dropdown on outside click
  useEffect(() => {
    if (!open) return;
    const handler = (e: MouseEvent) => {
      if (dropdownRef.current && !dropdownRef.current.contains(e.target as HTMLElement)) {
        setOpen(false);
      }
    };
    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, [open]);

  const getFlowElement = () =>
    document.querySelector<HTMLElement>(".react-flow");

  // ── Export handlers ───────────────────────────────────────

  const exportPNG = useCallback(async () => {
    const el = getFlowElement();
    if (!el) return;
    setExporting("png");
    try {
      const dataUrl = await toPng(el, {
        backgroundColor: isDark ? "#1e293b" : "#f9fafb",
        pixelRatio: 2,
      });
      downloadDataUrl(dataUrl, "agentic-flow-workflow.png");
    } catch (err) {
      console.error("PNG export failed:", err);
    } finally {
      setExporting(null);
      setOpen(false);
    }
  }, [isDark]);

  const exportSVG = useCallback(async () => {
    const el = getFlowElement();
    if (!el) return;
    setExporting("svg");
    try {
      const dataUrl = await toSvg(el, {
        backgroundColor: isDark ? "#1e293b" : "#f9fafb",
      });
      downloadDataUrl(dataUrl, "agentic-flow-workflow.svg");
    } catch (err) {
      console.error("SVG export failed:", err);
    } finally {
      setExporting(null);
      setOpen(false);
    }
  }, [isDark]);

  const exportJSON = useCallback(() => {
    if (!estimation) return;
    const json = buildJsonReport(estimation, nodes, edges);
    downloadBlob(json, "agentic-flow-report.json", "application/json");
    setOpen(false);
  }, [estimation, nodes, edges]);

  const exportMarkdown = useCallback(() => {
    if (!estimation) return;
    const md = buildMarkdownReport(estimation);
    downloadBlob(md, "agentic-flow-report.md", "text/markdown");
    setOpen(false);
  }, [estimation]);

  // ── NEW: Dashboard screenshot as PNG ─────────────────────
  const exportDashboardPNG = useCallback(async () => {
    const el = document.getElementById("estimate-dashboard-capture");
    if (!el) {
      // Fall back: try the panel's parent
      console.warn("Dashboard capture element not found");
      return;
    }
    setExporting("dashboard-png");
    try {
      // Temporarily expand the element to capture full scroll content
      const prevOverflow = el.style.overflow;
      const prevHeight = el.style.height;
      const prevMaxHeight = el.style.maxHeight;
      el.style.overflow = "visible";
      el.style.height = "auto";
      el.style.maxHeight = "none";

      const dataUrl = await toPng(el, {
        backgroundColor: isDark ? "#0f172a" : "#ffffff",
        pixelRatio: 2,
        width: el.scrollWidth,
        height: el.scrollHeight,
      });

      // Restore original scroll styles
      el.style.overflow = prevOverflow;
      el.style.height = prevHeight;
      el.style.maxHeight = prevMaxHeight;

      downloadDataUrl(dataUrl, "agentic-flow-dashboard.png");
    } catch (err) {
      console.error("Dashboard PNG export failed:", err);
    } finally {
      setExporting(null);
      setOpen(false);
    }
  }, [isDark]);

  // ── NEW: Report as CSV ───────────────────────────────────
  const exportCSV = useCallback(() => {
    if (!estimation) return;
    const csv = buildCsvReport(estimation);
    downloadBlob(csv, "agentic-flow-breakdown.csv", "text/csv");
    setOpen(false);
  }, [estimation]);

  // ── NEW: Report as PDF ───────────────────────────────────
  const exportPDF = useCallback(async () => {
    if (!estimation) return;
    setExporting("pdf");
    try {
      await generatePdfReport(estimation, isDark);
    } catch (err) {
      console.error("PDF export failed:", err);
    } finally {
      setExporting(null);
      setOpen(false);
    }
  }, [estimation, isDark]);

  const hasEstimation = estimation != null;

  const btnBase = `w-full text-left px-3 py-2 text-sm transition rounded ${
    isDark ? "hover:bg-slate-600" : "hover:bg-gray-100"
  }`;

  return (
    <div ref={dropdownRef} className="relative">
      <button
        onClick={handleToggle}
        className={`rounded-md border px-3 py-1.5 text-sm font-medium transition ${
          isDark
            ? "border-amber-700 text-amber-300 hover:bg-amber-800/40"
            : "border-amber-300 text-amber-700 hover:bg-amber-50"
        }`}
        title="Export workflow graph or estimation report"
      >
        <ChevronDown className="inline w-3.5 h-3.5 ml-1" /> Export
      </button>

      {open && (
        <div
          className={`absolute right-0 top-full z-50 mt-1 w-64 rounded-lg border shadow-lg ${
            isDark
              ? "border-slate-600 bg-slate-700 text-slate-200"
              : "border-gray-200 bg-white text-gray-800"
          }`}
        >
          <div className="p-1.5 space-y-0.5">
            {/* Graph exports — always available if nodes exist */}
            <p className={`px-3 pt-1.5 pb-1 text-[10px] font-semibold uppercase tracking-wide ${isDark ? "text-slate-400" : "text-gray-400"}`}>
              Graph Image
            </p>
            <button
              onClick={exportPNG}
              disabled={nodes.length === 0 || exporting === "png"}
              className={`${btnBase} disabled:opacity-40`}
            >
              {exporting === "png" ? "Exporting…" : <><Image className="inline w-3.5 h-3.5 mr-1" /> Canvas as PNG</>}
            </button>
            <button
              onClick={exportSVG}
              disabled={nodes.length === 0 || exporting === "svg"}
              className={`${btnBase} disabled:opacity-40`}
            >
              {exporting === "svg" ? "Exporting…" : <><Palette className="inline w-3.5 h-3.5 mr-1" /> Canvas as SVG</>}
            </button>

            {/* Dashboard capture — need estimation + open panel */}
            <div className={`my-1 border-t ${isDark ? "border-slate-600" : "border-gray-200"}`} />
            <p className={`px-3 pt-1.5 pb-1 text-[10px] font-semibold uppercase tracking-wide ${isDark ? "text-slate-400" : "text-gray-400"}`}>
              Dashboard Screenshot
            </p>
            <button
              onClick={exportDashboardPNG}
              disabled={!hasEstimation || exporting === "dashboard-png"}
              className={`${btnBase} disabled:opacity-40`}
              title={!hasEstimation ? "Run an estimation and open the dashboard first" : "Captures the full dashboard as a high-res image"}
            >
              {exporting === "dashboard-png" ? "Capturing…" : <><Camera className="inline w-3.5 h-3.5 mr-1" /> Dashboard as PNG</>}
            </button>

            {/* Report exports — need estimation */}
            <div className={`my-1 border-t ${isDark ? "border-slate-600" : "border-gray-200"}`} />
            <p className={`px-3 pt-1.5 pb-1 text-[10px] font-semibold uppercase tracking-wide ${isDark ? "text-slate-400" : "text-gray-400"}`}>
              Estimation Report
            </p>
            <button
              onClick={exportPDF}
              disabled={!hasEstimation || exporting === "pdf"}
              className={`${btnBase} disabled:opacity-40`}
              title={!hasEstimation ? "Run an estimation first" : "Professional PDF with tables and sections"}
            >
              {exporting === "pdf" ? "Generating…" : <><FileText className="inline w-3.5 h-3.5 mr-1" /> Report as PDF</>}
            </button>
            <button
              onClick={exportCSV}
              disabled={!hasEstimation}
              className={`${btnBase} disabled:opacity-40`}
              title={!hasEstimation ? "Run an estimation first" : "Node breakdown table — open in Excel / Google Sheets"}
            >
              <Table2 className="inline w-3.5 h-3.5 mr-1" /> Breakdown as CSV
            </button>
            <button
              onClick={exportJSON}
              disabled={!hasEstimation}
              className={`${btnBase} disabled:opacity-40`}
              title={!hasEstimation ? "Run an estimation first" : ""}
            >
              <ClipboardList className="inline w-3.5 h-3.5 mr-1" /> Report as JSON
            </button>
            <button
              onClick={exportMarkdown}
              disabled={!hasEstimation}
              className={`${btnBase} disabled:opacity-40`}
              title={!hasEstimation ? "Run an estimation first" : ""}
            >
              <FileCode className="inline w-3.5 h-3.5 mr-1" /> Report as Markdown
            </button>

            {!hasEstimation && (
              <p className={`px-3 py-1 text-[10px] italic ${isDark ? "text-slate-500" : "text-gray-400"}`}>
                Run an estimation to unlock dashboard, PDF, CSV, JSON &amp; Markdown exports.
              </p>
            )}
          </div>
        </div>
      )}
    </div>
  );
}
